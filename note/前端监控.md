# 前端监控，数据埋点


## 为什么需要前端监控
> 获取用户行为以及跟踪产品在用户端的使用情况，并以监控数据为基础，指明产品优化的方向。


## 前端监控三大类
1. 数据监控
2. 性能监控
3. 异常监控


## 数据监控
数据监控，顾名思义就是监听用户的行为

* PV/UV: PV(page view)，即页面浏览量或点击量。UV:指访问某个站点或点击某条新闻的不同IP地址的人数

* 用户在每一个页面的停留时间

* 用户通过什么入口来访问该网页

* 用户在相应的页面中触发的行为

> 统计这些数据是有意义的，比如我们知道了用户来源的渠道，可以促进产品的推广，知道用户在每一个页面停留的时间，可以针对停留较长的页面，增加广告推送等等。

## 性能监控
性能监控指的是监听前端的性能，主要包括监听网页或者说产品在用户端的体验。常见的性能监控数据包括：

* 不同用户，不同机型和不同系统下的首屏加载时间

* 白屏时间

* http等请求的响应时间

* 静态资源整体下载时间

* 页面渲染时间

* 页面交互动画完成时间

~~~javascript
DNS查询耗时 = domainLookupEnd - domainLookupStart
TCP链接耗时 = connectEnd - connectStart
request请求耗时 = responseEnd - responseStart
解析dom树耗时 = domComplete - domInteractive
白屏时间 = domloading - fetchStart
domready时间 = domContentLoadedEventEnd - fetchStart
onload时间 = loadEventEnd - fetchStart
~~~

> 这些性能监控的结果，可以展示前端性能的好坏，根据性能监测的结果可以进一步的去优化前端性能，比如兼容低版本浏览器的动画效果，加快首屏加载等等。

### 性能指标
| 字段 | 描述                              | 备注                                                         |
| ---- | --------------------------------- | ------------------------------------------------------------ |
| FP   | Frist Paint （首次绘制）          | 包括了任何用户自定义的背景绘制，表示首次将像素绘制到屏幕的时刻 |
| FCP  | Frist Content Paint(首次内容绘制) | 是浏览器将第一个dom渲染到浏览器的时间                        |
| FMP  | 首次有效绘制 /主角元素计时        | 页面有意义的内容渲染的时间                                   |
| LCP  | 最大内容渲染                      | 最大的页面元素渲染的时间                                     |
| DCL  | dom加载完成                       | 当html文档被完全加载和解析完成之后，domContentLoaded被触发   |
| L    | onload                            | 当依赖的资源完全加载完成后才会触发                           |
| TTI  | 可交互时间                        | 用于标记应用已进行视觉渲染并且能可靠相应用户行为的时间       |
| FID  | 首次输入延迟                      | 首次和页面交互到页面响应的时间                               |



## 异常监控

此外，产品的前端代码在执行过程中也会发生异常，因此需要引入异常监控。及时的上报异常情况，可以避免线上故障的发上。虽然大部分异常可以通过try catch的方式捕获，但是比如内存泄漏以及其他偶现的异常难以捕获。常见的需要监控的异常包括：

* Javascript的异常监控

* 样式丢失的异常监控

# 常用前端埋点方案

## 代码埋点

代码埋点，就是以嵌入代码的形式进行埋点，比如需要监控用户的点击事件，会选择在用户点击时，插入一段代码，保存这个监听行为或者直接将监听行为以某一种数据格式直接传递给server端。此外比如需要统计产品的PV和UV的时候，需要在网页的初始化时，发送用户的访问信息等。

代码埋点的优点：

可以在任意时刻，精确的发送或保存所需要的数据信息。

缺点：

工作量较大，每一个组件的埋点都需要添加相应的代码

## 可视化埋点
通过可视化交互的手段，代替代码埋点。将业务代码和埋点代码分离，提供一个可视化交互的页面，输入为业务代码，通过这个可视化系统，可以在业务代码中自定义的增加埋点事件等等，最后输出的代码耦合了业务代码和埋点代码。

可视化埋点听起来比较高大上，实际上跟代码埋点还是区别不大。也就是用一个系统来实现手动插入代码埋点的过程。

缺点：

可视化埋点可以埋点的控件有限，不能手动定制。

## 无埋点
无埋点并不是说不需要埋点，而是全部埋点，前端的任意一个事件都被绑定一个标识，所有的事件都别记录下来。通过定期上传记录文件，配合文件解析，解析出来我们想要的数据，并生成可视化报告供专业人员分析因此实现“无埋点”统计。

从语言层面实现无埋点也很简单，比如从页面的js代码中，找出dom上被绑定的事件，然后进行全埋点。

无埋点的优点：

由于采集的是全量数据，所以产品迭代过程中是不需要关注埋点逻辑的，也不会出现漏埋、误埋等现象

缺点：

无埋点采集全量数据，给数据传输和服务器增加压力

无法灵活的定制各个事件所需要上传的数据

# 前端埋点方案选型和前端上报方案设计

## 监控数据
首先我们需要明确一个产品或者网页，普遍需要监控和上报的数据。监控的分为三个阶段：用户进入网页首页、用户在网页内部交互和交互中报错。每一个阶段需要监控和上报的数据如下图所示：



## 埋点方案
在实际项目中考虑到上报数据的灵活定制，以及减少数据传输和服务器的压力，在所需埋点处不多的情况下，常用的方式是代码埋点。

以用户进入首页为例，我们在首页渲染完成后会发送事件类型和类型相关的数据给server端，告知首页的监控信息。


## 上报周期和上报数据类型
如果埋点的事件不是很多，上报可以时时进行，比如监控用户的交互事件，可以在用户触发事件后，立刻上报用户所触发的事件类型。如果埋点的事件较多，或者说网页内部交互频繁，可以通过本地存储的方式先缓存上报信息，然后定期上报。

接着来确定需要埋点上报的数据，上报的信息包括用户个人信息以及用户行为，主要数据可以分为：

1. who: appid(系统或者应用的id),userAgent(用户的系统、网络等信息)
2. when: timestamp(上报的时间戳)
3. from where: currentUrl(用户当前url)，fromUrl(从哪一个页面跳转到当前页面)，type(上报的事件类型),element(触发上报事件的元素）
4. what: 上报的自定义扩展数据data:{},扩展数据中可以按需求定制，比如包含uid等信息

## 埋点和上报举例
我们以上报首屏加载事件为例，DOM提供了document的DOMContentLoaded事件来监听dom挂载，提供了window的load事件来监听页面所有资源加载渲染完毕。
~~~html
<script type="text/javascript">
  var start=Date.now();
  document.addEventListener('DOMContentLoaded', function() {
     fetch('some api',
     {   
         type:'dom complete',
         data:{
           domCompletedTime:Date.now()-start
         }
     })
  });
  window.addEventListener('load',
   function() {
     fetch('some api',
     {         
         type:'load complete',
         data:{
           LoadCompletedTime:Date.now()-start
         }
     })
  });
</script>
~~~

## 前端埋点系统的前后端通信加密

在上报数据的前后端通信中，需要和server端协商加密机制，利用 OpenSSL库来实现的加密，OpenSSL已经是一个广泛被采用的加密算法。前端可以采用node的crypto模块。

首先来看hash算法，crypto.createHash() 来创建一个Hash实例，可利用的hash算法如下：

1. md5
2. sha1
3. sha256
4. sha512
5. ripemd160

以sha256算法加密为例：

~~~javascript
const str="123445";
//需要加密的字段
const hash=crypto.createHash('sha256');
//指定加密算法
hash.update(str); 
//通过算法加密相应的字段
const result=hash.digest('hex');
//转化成十六进制复制代码
~~~

# 前端监控结果可视化展示系统的设计

当后端得到前端上报的信息之后，经过数据分析和处理，需要前端可视化的展示数据分析后的结果。

可以在开源中后台系统ant-design-pro的基础上进行二次开发，首先要明确展示信息。展示的信息包括单个用户和整体应用。

对于单个用户来说需要展示的监控信息为：

1. 单个用户，在交互过程中触发各个埋点事件的次数

2. 单个用户，在某个时间周期内，访问本网页的入口来源

3. 单个用户，在每一个子页面的停留时间

对于全体用户需要展示的信息为：

1. 某一个时间段内网页的PV和UV

2. 全体用户访问网页的设备和操作系统分析

3. 某一个时间段内访问本网页的入口来源分析

4. 全体用户在访问本网页时，在交互过程中触发各个埋点事件的总次数

全体用户在访问本网页时，网页上报异常的集合

删选功能集合：

时间筛选：提供今日（00点到当前时间）、本周、本月和全年

用户删选：提供根据用户id删选出用户行为的统计信息

设备删选：删选不同系统的整体展示信息



前端更关注的性能指标在首屏，比如：

HTML 加载完成时间

首屏图片加载完成时间

首屏接口完成加载完成时间

代码实现
这个时候，我们可以自己手动加上一些时间点(这里的手动添加的点都推荐使用performance.now来实现)，结合一起上报。代码示例如下：

~~~javascript
//window.loadHtmlTime 在html中的</body>标签前面用打个时间戳即可
HTMLComplete = window.loadHtmlTime - window.performance.timing.navigationStart
 
//window.lastImgLoadTime 在首屏中的每张图onload之后都更新一次这个时间戳
firstScreenImgFinished = window.lastImgLoadTime - window.performance.timing.navigationStart
 
//Report.SPEED.MAINCGI 在首屏中的每个接口调用成功后更新时间戳
firstScreenApiFinished = Report.SPEED.MAINCGI - window.performance.timing.navigationStart
 
//在所有接口打时间点
apiFinishes = Report.SPEED.LASTCGI - window.performance.timing.navigationStart);
~~~

注意：

我们在做性能埋点的时候，最好不要入侵业务代码。这里我的想法是，每个api调用的方法，我们都返回一个Promise，这样，我们再另外封装一个sdk去找到这些方法，然后分别注册then方法来计时即可。

window.performance.getEntries()

window.performance.getEntries 是一个方法，方法调用后可以获取一个包含了页面中所有的 HTTP 请求的时间数据的数组.这个数组是一个按startTime排序的对象数组，数组成员除了会自动根据所请求资源的变化而改变以外，还可以用mark(),measure()方法自定义添加。

其与 performance.timing 对比的差别就是没有与 DOM 相关的属性。而要注意的是， HTTP 请求有可能命中本地缓存，这种情况下请求响应的间隔将非常短，数据可能不准确。

 